{"id":"features/grid/virtual-scroll/what-is-virtual-scroll","title":"What is Virtual Scroll?","contents":"<h1 id=\"virtual-scroll-basics\"><a href=\"#virtual-scroll-basics\" aria-hidden><span class=\"icon icon-link\"></span></a>Virtual Scroll Basics</h1>\n<p>Displaying rows, rendering and keeping them synced is an expansive task. Adding more columns equals more work.</p>\n<p>If our dataset contains 100 rows &#x26; 5 columns, displaying them is not an issue.<br>\nNow, a new dataset with 100,000 rows. That's <strong>at minimum</strong> 600,000 DOM elements, 100K rows + 500K cells.</p>\n<p>In reality, the browser will start showing slow initial loading at 500 rows and hang at 1000+ and that's only 5 columns!<br>\nWhen we think about it, why do we need to render all rows? the user can only see several rows at a time.</p>\n<p>To solve this issue we apply <strong>virtual scrolling</strong>, a technique that renders only the visible rows (plus additional row for buffering).<br>\nAll other rows are emulated (virtualized) and only when the user scroll's the context of each row is swapped but we usually don't\ngenerate new rows.</p>\n<p>We only show a small portion of data at a given time.<br>\nOther items should be emulated (virtualized) via elements that create empty space, which are empty but have some height necessary to provide consistent scrollbar parameters.<br>\nEach time the user scrolls out of the set of visible items, the content is rebuilt: new items are fetched and rendered, old ones are destroyed, padding elements are recalculated, etc.</p>\n<blockquote class=\"info icon\">\n<div class=\"icon-location\"></div>\n For an in-depth tutorial, see \n<a href=\"https://blog.logrocket.com/virtual-scrolling-core-principles-and-basic-implementation-in-react/\">this blog post</a>\n</blockquote>\n<p>As always, there are challenges. At the start, we start with 100K rows, let say we render 10 but to display the scrollbar properly\nwe need to estimate the total length of the remaining 99,990 row we still didn't render. As the user scrolls we need to\ndetermine the next subset of rows to fetch.</p>\n<p>If we know that all rows have a fixed height we can apply specific logic, if we need to automatically calculate the heights we will apply a different logic.<br>\nWe call the different logics <strong>strategies</strong>.</p>\n<p><strong>nGrid</strong> comes with 3 built-in strategies, suitable for different scenarios.</p>\n<blockquote class=\"info icon\">\n<div class=\"icon-location\"></div>\n You can provide a custom strategy if you have one, however this is usually complicated.\n</blockquote>\n<blockquote class=\"info icon\">\n<div class=\"icon-location\"></div>\n Logic by itself is not enough, the strategy must be able to cope with other elements in the grid, such as header, sticky rows, etc..\n</blockquote>\n<div pbl-example-view=\"pbl-virtual-scroll-example\"></div>\n"}